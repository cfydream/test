{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Viterbi\n",
    "\n",
    "Alice and Bob are working together to bake some treats while they are home for winter break.\n",
    "Alice is in charge of sending Bob the recipe, and Bob is responsible for following directions.\n",
    "Bob is *extremely* literal- if an error in the recipe says to use 2000 eggs instead of 2, he will use 2000 eggs without a second thought.\n",
    "Alice is aware of Bob's lack of common sense, but she is also busy.\n",
    "She already has the recipe open on her phone, so she wants to send it via email (using wifi) to Bob.\n",
    "Unfortunately, Alice's evil next-door-neighboor Eve has her microwave running continuously at maximum power.\n",
    "Microwaves emit a lot of radiation around wifi's 2.4GHz channels, causing interference.\n",
    "This lab will explore different techniques for ensuring that Alice's message will make it to Bob uncorrupted."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Preliminaries\n",
    "\n",
    "We assume that Alice's message is $N$ bits long with each bit iid Bernoulli(0.5).\n",
    "We model the channel as a [binary symmetric channel](http://en.wikipedia.org/wiki/Binary_symmetric_channel), as shown below.\n",
    "Each bit sent through the channel is flipped (independently) with probability p.\n",
    "We'll assume p=0.05, which is a fairly typical value for wireless communications.\n",
    "\n",
    "![Alt](http://upload.wikimedia.org/wikipedia/commons/8/8e/Binary_symmetric_channel_%28en%29.svg)\n",
    "\n",
    "We assume that Alice and Bob use some sort of message integrity check in their message (like a [CRC](http://en.wikipedia.org/wiki/Cyclic_redundancy_check)) - to keep things simple, let's assume Bob can detect any error with probability 1.\n",
    "\n",
    "We also assume that Bob sends Alice an ACK or NACK and assume that this message always succeeds.\n",
    "If Bob sends an ACK, Alice knows Bob got the message.\n",
    "If Bob sends a NACK, Alice tries to send again."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Repetition Code\n",
    "We need a way to correct errors introduced by our noisy channel.\n",
    "One of the simplest error correcting codes is the [repetition code](http://en.wikipedia.org/wiki/Repetition_code).\n",
    "\n",
    "Repetition coding works by having Alice send each bit of her message $r$ times. Assuming each a 0 or 1 is equally likely and the crossover probability is less than 0.5, the optimal decoder is to use majority logic - i.e. for $r=3$ if Bob gets two 1s and one 0, he will decide 1. Ties are broken uniformly at random."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Q1 Repetition Coding\n",
    "### (A)\n",
    "Denoting the crossover probability as $p <0.5$, write an explicit formula for the probability of a single bit error (denoted $P_b$) as a function of $r$. Be sure to take special care of the case when $r$ is even."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## <font color='blue'> Let $X$ be the bit Alice is sending, $Y_{i}$ be the $i$th received bit, $Y = \\sum_{i=1}^{r}Y_{i}$, and $Z = \\sum_{i=1}^{r}Z_{i}$ be the channel noise, per lecture notes 14/15.  Then $Y_{i} = (X + Z_{i}) mod 2$.  We note without $Z$, there is no noise or random-ness, so we really need only model $Z$.  $P(Z =0) = (1-p)$ and $P(Z=1)=p$.  Bruce is wrong when $Z>r/2$ and half the time when $Z=r/2$, no matter the value of $X$.  \n",
    "\n",
    "\\begin{align*}\n",
    "P(Error) &= P(Z>r/2) + 1/2P(Z=r/2)\\\\\n",
    "&= \\sum_{k=r/2+\\alpha}^{r} \\binom{r}{k} p^{k}(1-p)^{r-k} + 1/2p^{r/2}(1-p)^{r/2}\\\\\n",
    "\\end{align*}\n",
    "Where $\\alpha = 1/2,r odd$, and $\\alpha = 1, r even$, and the second term only applies when r is even.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### (B)\n",
    "For $p = 0.02$, $p = 0.05$ and $p =0.1$ plot $P_b$ for $r \\in \\{1,2,3,\\ldots,14,15\\}$. Use the semilogy command when plotting your bit error rate (BER). Be sure to label your axes and include a legend.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "image/png": [
       "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\n"
      ],
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f6a4a3ab790>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#%pylab\n",
    "%matplotlib inline\n",
    "from __future__ import division\n",
    "from scipy.stats import binom\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "rmax = 15 #highest number of redundant bits\n",
    "redundancy = np.arange(1, rmax+1)\n",
    "\n",
    "pFail = [.02,.05,.1] #probability of channel flip\n",
    "results = {} #dictionary to connect p in pFail to the Probability of failure given that p, in a vector indexed to r\n",
    "\n",
    "#compute Pb for each p, input result vector into the pFail dictionary:\n",
    "\n",
    "for p in pFail:\n",
    "    Pb = np.zeros(rmax)\n",
    "    for r in redundancy:\n",
    "        if r % 2 != 0:  #odd\n",
    "            Pb[r-1] = sum(binom.pmf(np.arange(r/2+.5,r+1),r,p))                \n",
    "        else:           #even\n",
    "            Pb[r-1] = sum(binom.pmf(np.arange(r/2+1,r+1),r,p)) + 0.5*binom.pmf(r/2,r,p)\n",
    "    results[p] = Pb\n",
    "    \n",
    "\n",
    "plt.figure()\n",
    "for i in range(3):\n",
    "    plt.semilogy(redundancy, results[pFail[i]], label = \"p = \" + str(pFail[i])) \n",
    "plt.grid('on')\n",
    "plt.legend()\n",
    "plt.xlabel('repetition of bits sent (n)')\n",
    "plt.ylabel('P(error)')\n",
    "plt.show()  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###(C)\n",
    "Why in practice would you avoid using an even number of repetitions?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## <font color='blue'>We can see for a given \\textit{even} number of $r$ repetitions, the probability of failure is more than that of $r-1$ repetitions.  This comes from the 50% probability of being wrong when an half the bits are transmitted in error. So the extra bit sent to make $r$ comes with the cost of transmitting another redundant bit, and an increased chance of error."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Convolutional Coding\n",
    "It should make intuitive sense that we can get to low probabilities of error if we increase the number of repetitions.\n",
    "However, increasing the number of repetitions means we are lowering Alice's effective datarate.\n",
    "Alice's phone also has limited battery life, and sending lots of copies of the same data consumes a lot of energy.\n",
    "Is it possible to correct a lot of errors without having to send so many extra bits? \n",
    "\n",
    "Yes! The 802.11 standards for wifi use convolutional codes and LDPC codes to correct errors.\n",
    "Convolutional codes can be efficiently decoded using the Viterbi algorithm, so they will be the focus of this lab.\n",
    "<img src=\"http://imgur.com/BzlsY89.png\" width=\"500px\"></img>\n",
    "\n",
    "The above picture is a block diagram for a simple convolutional encoder.\n",
    "The input message is treated as a stream of bits \n",
    "\n",
    "$$d_0, d_1, d_2, d_3 \\ldots$$\n",
    "\n",
    "The input is shifted through a series of delays - at time k, the input is $d_k$, the first delay element (the \"D\" on the left) contains $d_{k-1}$, and the last delay elements (the \"D\" on the right) contains $d_{k-2}$.\n",
    "In this example, each input bit produces two output bits - the first output computed by the top \"adder\" and the second output computed by the bottom \"adder\". We denote the output of the top adder as $u_k$ and the bottom adder as $v_k$. The equations for each are given by\n",
    "\n",
    "\\begin{align*}\n",
    "u_k &= d_k + d_{k-2} &\\mod 2\\\\\n",
    "v_k &= d_k + d_{k-1} + d_{k-2} &\\mod 2\n",
    "\\end{align*}\n",
    "\n",
    "We further define $d_{-2}= d_{-1}=0$ for initalization of the algorithm. The two outputs are interleaved into one bitstream so the output is $(u_0, v_0, u_1, v_1, u_2, v_2, ...)$.\n",
    "\n",
    "The first thing to note is that this is not actually all that different from repetition coding.\n",
    "Like repetition coding, we are adding redundancy by generating multiple output bits per input bit.\n",
    "However, unlike repetition coding, convolutional codes have *memory*.\n",
    "Each output bit is a function of multiple input bits.\n",
    "The idea is that if there is an error, you should be able to use the surrounding bit estimates to help you figure out what was actually sent.\n",
    "\n",
    "The figure below shows the state transition diagram corresponding to the example encoder above.\n",
    "Each transition is labelled $d_k/(u_k, v_k)$.\n",
    "The two bits inside the circle correspond to the *state*. In order to compute the next output we must have $d_{k-2},d_{k-1}$ so we represent our state to as two numbers $d_{k-2}d_{k-1}$ (of which there are 4 different combinations). \n",
    "\n",
    "As an example, consider the state $10$ and the transition $1/00$. We first identify $d_{k-2} = 1$ and $d_{k-1}=0$ from the state. From the transition information we identify $d_k = 1$, $u_k = 0$, and $v_k = 0$ (note that $u_k$ and $v_k$ need not be given as they are entirely determined by the other three variables). The new state is then $d_{k-1}d_k = 10$ which is consistent with the diagram\n",
    "\n",
    "Be sure to convince yourself that the encoder above is equivalent to the state transition diagram below.\n",
    "\n",
    "<img src=\"http://imgur.com/W9fSfpn.png\" width=\"300px\"></img>\n",
    "\n",
    "If we assume that the input bits are iid Bernoulli(0.5), this is a Markov chain with every state equally likely.\n",
    "We can run the Viterbi algorithm on our output bits (even after going through a noisy channel) to recover a good estimate of the input bits.\n",
    "\n",
    "We assume that we start state 0.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Q2 The Convolutional Encoder\n",
    "###(A)\n",
    "Implement the encoder described by the block diagram above."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pdb\n",
    "\n",
    "# Convolutional Encoder\n",
    "# Precondition:  An array of ones and zeros (raw message)\n",
    "# Postcondition: An output stream of u(k) and v(k), per the above encoder instructions\n",
    "def encode(message):\n",
    "    fullmessage = np.concatenate(([0,0],message))  #prepend zero data\n",
    "    output = []\n",
    "    \n",
    "    for i in np.arange(2,len(fullmessage)):\n",
    "        u = (fullmessage[i] + fullmessage[i-2]) % 2\n",
    "        v = (fullmessage[i] + fullmessage[i-1] + fullmessage[i-2]) % 2\n",
    "        output = np.concatenate((output, [u, v]))\n",
    "                       \n",
    "    return output"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###(B)\n",
    "Print your encoder's output on the following bit streams."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 1.  1.  1.  0.  1.  0.  0.  0.  0.  1.]\n",
      "[ 0.  0.  1.  1.  0.  1.  0.  0.  0.  1.]\n"
     ]
    }
   ],
   "source": [
    "print encode([1,1,0,1,0])\n",
    "print encode([0,1,0,1,0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Q3 State Estimation of a Hidden Markov Model\n",
    "We start by defining the random variables associated with the problem. We let $X_0,X_1,X_2\\ldots$ be the binary random variables which are input into the encoder. We further define the random variables $U_0,U_1,\\ldots$ and $V_0,V_1,\\ldots$ to the result of the upper and lower branch of the convolutional encoding of $X_0,X_1,\\ldots$. Lastly, we let $Y_0^u,Y_1^u,\\ldots$ be the output when $U_0,U_1,\\ldots$ are passed through the binary symmetric channel. We define $Y_0^v,Y_1^v,\\ldots$ analogously for the $V_i$'s\n",
    "\n",
    "### (A)\n",
    "Draw a block diagram illustrating the relationships between the above random variables"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"files/Lab3q3b_scale.jpeg\">"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### (B)\n",
    "Show that if the $X_i$'s are i.i.d. and equally probable 0 or 1, then the MAP rule\n",
    "\n",
    "$$\\arg \\max_{d_0,\\ldots,d_n}\\boldsymbol{P}(X_0=d_0,\\ldots, X_n = d_n| Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n)$$\n",
    "\n",
    "is equivalent to the Maximum Likelihood rule\n",
    "\n",
    "$$\\arg \\max_{d_0,\\ldots,d_n} \\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|X_0=d_0,\\ldots, X_n = d_n)$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## <font color='blue'>We start with the MAP rule, and first implement Baye's rule, as in lecture 17:\n",
    "\\begin{align*}\n",
    "\\arg \\max_{d_0,\\ldots,d_n}\\boldsymbol{P}(X_0=d_0,\\ldots, X_n = d_n| Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n)\\\\\n",
    "= \\arg \\max_{d_0,\\ldots,d_n}\\boldsymbol{P}\\frac{(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|X_0=d_0,\\ldots, X_n = d_n)\\boldsymbol{P}(X_0=d_0,\\ldots, X_n = d_n)}{\\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n )}\\\\\n",
    "\\end{align*}\n",
    "## <font color='blue'>As we are maximizing with respect to the inputs, we can let the denominator go to 1\n",
    "\\begin{align*}\n",
    "= \\arg \\max_{d_0,\\ldots,d_n}\\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|X_0=d_0,\\ldots, X_n = d_n)\\boldsymbol{P}(X_0=d_0,\\ldots, X_n = d_n)\\\\\n",
    "\\end{align*}\n",
    "## <font color='blue'>If each X is iid and unbiased $\\in\\{0,1\\}$, \n",
    "\\begin{align*}\n",
    "\\boldsymbol{P}(X_0=d_0,\\ldots, X_n = d_n) = \\boldsymbol{P}(X_0=d_0),\\ldots, \\boldsymbol{P}(X_n = d_n) = 0.5^{n}\\\\\n",
    "\\end{align*}\n",
    "## <font color='blue'>Since there is nothing to maximize there, we can remove these from the function as well without disturbing its maximization solution, and we are left with the maximum likelihood rule. QED"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### (C)\n",
    "Show that if $Z_1$, $Z_2$ and $Z_3$ are random variables such that $Z_1$ and $Z_3$ are independent conditional on $Z_2$ and $Z_2$ is a function of $Z_1$ (i.e. $Z_2 = g(Z_1)$) then \n",
    "\n",
    "$$\\boldsymbol{P}(Z_3 = a|Z_1 = b) = \\boldsymbol{P}(Z_3 = a|Z_2 = g(b))$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## <font color='blue'>From the definition of conditional independence:\n",
    "\\begin{align}\n",
    "\\boldsymbol{P}(Z_3 = a|Z_2 = g(b)) = \\boldsymbol{P}(Z_3 = a|Z_2 = g(b) \\cap Z_1 = b))\\\\\n",
    "\\end{align}\n",
    "## <font color='blue'>Since $Z_2$ is a function of $Z_1$,\n",
    "\\begin{align*}\n",
    "\\boldsymbol{P}(Z_2 = g(b)|Z_1 = b) = 1 = \\frac{\\boldsymbol{P}(Z_2 = g(b) \\cap Z_1 = b)}{\\boldsymbol{P}(Z_1 = b)}\\\\\n",
    "\\boldsymbol{P}(Z_1 = b) = \\boldsymbol{P}(Z_2 = g(b) \\cap Z_1 = b)\\\\\n",
    "(Z_1 = b) = (Z_2 = g(b) \\cap Z_1 = b)\n",
    "\\end{align*}\n",
    "## <font color='blue'> We substitute this into (1)\n",
    "\\begin{align}\n",
    "\\boldsymbol{P}(Z_3 = a|Z_2 = g(b)) = \\boldsymbol{P}(Z_3 = a|Z_1 = b))\\\\\n",
    "\\end{align}\n",
    "## <font color='blue'> QED"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### (D)\n",
    "Using part(C) or otherwise, show that the expression in part(B) is equivalent to \n",
    "\n",
    "$$\\arg \\max_{d_0,\\ldots,d_n} \\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|U_0=u_0, V_0 =v_0\\ldots, U_n = u_n, V_n=v_n)$$\n",
    "\n",
    "where $(u_0,v_0,\\ldots,u_n,v_n)$ is the output stream corresponding to the input stream.\n",
    "\n",
    "*Hint: take $Z_1 = (X_0,X_1,\\ldots, X_n$)*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## <font color='blue'>Per the hint, we let $Z_1 = (X_0,X_1,...,X_n)$, and $P(Z_1 = \\alpha) = P(X_0 = d_0, X_1 = d_1, ..., X_n = d_n)$.  Since each $U_i, V_i$ are a function of a subset of $(X_0,...,X_n)$, they are a function of $(X_0,...,X_n)$.  Let P(U_0=u_0, V_0 =v_0\\ldots, U_n = u_n, V_n=v_n) = P(Z_2 = \\beta)$.  Then $P(Z_2=\\beta) = P(Z_2 = g(\\alpha)) = P(Z_1 = \\alpha)$.  And so, \n",
    "\n",
    "\\begin{align*}\n",
    "&\\arg \\max_{d_0,\\ldots,d_n} \\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|X_0=d_0,\\ldots, X_n = d_n) \\\\\n",
    "&= arg \\max_{d_0,\\ldots,d_n} \\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|Z_1 = \\alpha)  \\\\\n",
    "&= arg \\max_{d_0,\\ldots,d_n} \\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|Z_2 = \\beta) \\\\\n",
    "&= arg \\max_{d_0,\\ldots,d_n} \\boldsymbol{P}(Y^u_0 =a_0, Y_0^v = b_0,Y^u_1 =a_1, Y_1^v = b_1,\\ldots,Y^u_n =a_n, Y_n^v = b_n|U_0=u_0, V_0 =v_0\\ldots, U_n = u_n, V_n=v_n)\n",
    "\\end{align*}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### (E) \n",
    "Convince yourself that the maximization in part (D) can be solved using the Viterbi algorithm on the Markov chain above with an appropriate metric associated with each transition in the chain (branch metric). Give an explicit expression for the branch metric."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## <font color='blue'>I choose the Hamming distance between the $Y_i^u, Y_i^v$ and that of the possible states $U_i, V_i$, $\\in \\{0,1,2\\}$, which is simply the absolute value of the difference of the bits recieved and possible states of the system.\n",
    "\n",
    "Motivated from: http://home.netcom.com/~chip.f/viterbi/algrthms2.html"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Q4 The Viterbi Algorithm\n",
    "###(A)\n",
    "In the space below, implement a viterbi decoder for our 4-state example code."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from __future__ import division\n",
    "\n",
    "def viterbi(bits_in):\n",
    "    # States (x[n-2], x[n-1]) as well as convolutional code pairs (u,v) are stored in arrays /data as follows:\n",
    "    # 0,0 = 0 \n",
    "    # 0,1 = 1\n",
    "    # 1,0 = 2\n",
    "    # 1,1 = 3\n",
    "    \n",
    "    # converts two binarys to indices per the above ruleset:\n",
    "    def convert(a,b):\n",
    "        if a == 0 and b == 0:\n",
    "            return 0\n",
    "        elif a == 0 and b == 1:\n",
    "            return 1\n",
    "        elif a == 1 and b ==0:\n",
    "            return 2\n",
    "        else: return 3\n",
    "    \n",
    "    # returns the hamming value (transition metric) of data having been converted to the range (0..3)\n",
    "    def getHam(x, y):\n",
    "        if x == 0 and y == 0:   return 0\n",
    "        elif x == 0 and y == 1: return 1\n",
    "        elif x == 0 and y == 2: return 1\n",
    "        elif x == 0 and y == 3: return 2\n",
    "        elif x == 1 and y == 0: return 1\n",
    "        elif x == 1 and y == 1: return 0\n",
    "        elif x == 1 and y == 2: return 2\n",
    "        elif x == 1 and y == 3: return 1\n",
    "        elif x == 2 and y == 0: return 1\n",
    "        elif x == 2 and y == 1: return 2\n",
    "        elif x == 2 and y == 2: return 0\n",
    "        elif x == 2 and y == 3: return 1\n",
    "        elif x == 3 and y == 0: return 2\n",
    "        elif x == 3 and y == 1: return 1\n",
    "        elif x == 3 and y == 2: return 1\n",
    "        elif x == 3 and y == 3: return 0\n",
    "        \n",
    "    # table of allowed state transitions (tells if row(State) can transition to column(State).  Value is None if \n",
    "    # not possible, else value is the index (convert(u,v)) of the code (u,v pair) that makes that transition\n",
    "    allowedStateTrans = [[0,3,None,None],[None,None,1,2],[3,0,None, None],[None, None, 2, 1]]\n",
    "    \n",
    "    # data = database: a list of lists of dictionaries.  \n",
    "    # time and state are referenced by data[time][state] \n",
    "    # Each dictionary has keys: past state, past Hamm Error, current Hamm error\n",
    "    # state attributes are reference by data[time][state]['key']\n",
    "    data = []\n",
    "\n",
    "    #########\n",
    "    #initialize for time 1\n",
    "    ############\n",
    "    data.append([]) # append a list to describe all states at time 1, each state is a dictionary\n",
    "    pastState = 0\n",
    "    # 1D vector, each column is end state, each element is transition code if an allowed transition, None if not\n",
    "    possibleNewStates = allowedStateTrans[pastState] \n",
    "    for i in np.arange(4): # iterate over states \n",
    "        data[0].append({}) # each dictionary is attributes of a given state\n",
    "        if possibleNewStates[i] != None: # if an allowed transition: \n",
    "            # this stores the hamming distance between the bits_in code and the possible new States            \n",
    "            data[0][i]['pastState'] = 0\n",
    "            data[0][i]['pastHammError'] = 0\n",
    "            data[0][i]['currHammError'] = getHam(convert(bits_in[0],bits_in[1]), (possibleNewStates[i]))\n",
    "    ###########################\n",
    "\n",
    "    \n",
    "    #########\n",
    "    # comparePaths(new input data, previous state information)\n",
    "    # comparePaths populates a new state information given new input uv pair.  It looks at all possible transitions\n",
    "    # between the old state and new states, calculates the accumulated error of each transition, and chooses\n",
    "    # lower error if mulitple paths arrive at a given state.\n",
    "    # Precondition:  an input of received uv pair converted to (0..3)\n",
    "    #                a  list of dictionaries for time t-1 lastData [{},{},{},{}]\n",
    "    # Postcondition: a list of dictionaries for time t\n",
    "    ########\n",
    "    def comparePaths(received, lastStates):\n",
    "        newStates = [{},{},{},{}] #a list of dictionaries, one for each state\n",
    "        tempState = {}\n",
    "        for i in np.arange(4): #iterate over old states\n",
    "            if lastStates[i]: \n",
    "                # if the state in the last time step (lastData) was occupied, we need to propagate if forward.\n",
    "                transitions = allowedStateTrans[i] #allowed transitions from state i to state j (None if not allowed)\n",
    "                for j in np.arange(4): #iterate over new states\n",
    "                    if transitions[j] != None: #if an allowed transition from state i to state j,\n",
    "                        tempState['pastState'] = i\n",
    "                        tempState['pastHammError'] = lastStates[i]['currHammError']\n",
    "                        tempState['currHammError'] = getHam(received, transitions[j]) + tempState['pastHammError'] \n",
    "                        if not newStates[j]: #state is empty, populate with tempState\n",
    "                            newStates[j] = tempState.copy()\n",
    "                        else:  #state is occupied, compare cumulative error between state and temp state.  \n",
    "                               #Smaller error wins, in tie, no change\n",
    "                            a =    newStates[j]['currHammError'] \n",
    "                            b =       tempState['currHammError'] \n",
    "                            if a > b:\n",
    "                                newStates[j] = tempState.copy()                   \n",
    "        return newStates  \n",
    "    \n",
    "    ######\n",
    "    # calculate for time > 1\n",
    "    ######\n",
    "    for j in np.arange(1,len(bits_in)//2):\n",
    "        # j corresponds to time: j = t -1 \n",
    "        # this correlates to bits 2*j (u) and 2*j + 1 (v)\n",
    "        received = convert(bits_in[2*j],bits_in[2*j+1])\n",
    "        data.append([])\n",
    "        data[j] = comparePaths(received,data[j-1]) # temporarily holds state information until lowest accumulated error is decided upon.  Then\n",
    "\n",
    "        \n",
    "    # now we have the path lengths at each step, we start at the end of the algorithm and work backwards, choosing\n",
    "    # the shortest path (smallest error) at each step\n",
    "    finalError = np.zeros(4)\n",
    "    for i in np.arange(4):\n",
    "        finalError[i] = data[-1][i]['currHammError'] + data[-1][i]['pastHammError']\n",
    "    path = [np.argmin(finalError)] #the index of the state with the smallest error in the final state\n",
    "    path = [data[-1][path[0]]['pastState']] + path #prepend the past state of the smallest error final state to path\n",
    "    \n",
    "    #start one from final state, work backworks, prepending states as we go\n",
    "    for i in np.arange(len(data)-2,0,-1): \n",
    "        stepBack = [data[i][path[0]]['pastState']]\n",
    "        path =     stepBack + path\n",
    "    \n",
    "    #maps the (0..3) indexes of state to bits produced pairs of x(n-2), x(n-1) bits\n",
    "    def de_convert(path):\n",
    "        message = []\n",
    "        for i in np.arange(len(path)):\n",
    "            if path[i]%2 != 0:\n",
    "                message = message + [1]\n",
    "            else:\n",
    "                message = message + [0]\n",
    "        return message   \n",
    "    \n",
    "    message = de_convert(path)\n",
    "    \n",
    "    return message"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###(B)\n",
    "The following code block defines two functions, one which converts strings to their binary ASCII representations, and the other that converts from bits to ASCII. Use your implementation of the Viterbi Algorithm to decode the message in 'secret.txt' (which has been encoded using the convolutional code described in this lab)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "#thanks http://stackoverflow.com/questions/10237926/convert-string-to-list-of-bits-and-viceversa\n",
    "def tobits(s):\n",
    "    result = []\n",
    "    for c in s:\n",
    "        bits = bin(ord(c))[2:]\n",
    "        bits = '00000000'[len(bits):] + bits\n",
    "        result.extend([int(b) for b in bits])\n",
    "    return result\n",
    "\n",
    "def frombits(bits):\n",
    "    chars = []\n",
    "    for b in range(len(bits) // 8):\n",
    "        byte = bits[b*8:(b+1)*8]\n",
    "        chars.append(chr(int(''.join([str(bit) for bit in byte]), 2)))\n",
    "    return ''.join(chars)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Nice work, you're almost with the last lab of the quarter!\n"
     ]
    }
   ],
   "source": [
    "fin = open('secret.txt', 'r')\n",
    "secret_bits = [int(i) for i in fin.read()[1:-1].split(',')]\n",
    "fin.close()\n",
    "\n",
    "print frombits(viterbi(secret_bits))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "\n",
    "## Q5.  Empirical Bit Error Rate of Convolutional Coding\n",
    "### (A) \n",
    "So how does the convolutional code compare with simple repetition coding?\n",
    "We are going to plot the bit error rate. \n",
    "\n",
    "$$ BER =\\frac{\\textrm{Number of incorrectly decoded bits}}{\\textrm{Total number of bits}}$$ \n",
    "\n",
    "for some different channel parameters. For $0.01\\le p \\le 0.1$ on the x-axis, plot the bit error rate on a log scale on the y-axis. Run *100 trials* for randomly generated 512-bit long inputs at each channel parameter (this might take a little while to run). Note that we have given you the code to simulate the binary symmetric channel.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "image/png": [
       "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\n"
      ],
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f6a4a679210>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from matplotlib import pyplot as plt\n",
    "%matplotlib inline\n",
    "# Simulate the binary symmetric channel which corrupts the original bitstream with probability p\n",
    "def bsc(bits_in, p=.05):\n",
    "    out = []\n",
    "    for b in bits_in:\n",
    "        if np.random.uniform() > p:\n",
    "            out.append(b)\n",
    "        else:\n",
    "            out.append(1-b)\n",
    "    return np.array(out)       \n",
    "\n",
    "# Plot against these values of the crossover probability p\n",
    "ps = np.linspace(0.01, 0.1, 10)\n",
    "\n",
    "# Find number of errors. requires sent and received to be same size binary lists.\n",
    "def numErrors(sent, received):\n",
    "    badBits = 0\n",
    "    for i in np.arange(len(sent)):\n",
    "        if sent[i] - received[i] != 0:\n",
    "            badBits += 1\n",
    "    return badBits\n",
    "\n",
    "N = 100 #num trials\n",
    "L = 512 #length of message\n",
    "\n",
    "BER = np.zeros(shape = (len(ps),2)) #\n",
    "    \n",
    "for k in np.arange(len(ps)):  # iterate over each probability\n",
    "    BER[k,0] = ps[k]\n",
    "    for i in np.arange(N):\n",
    "        msg        = np.ndarray.tolist(np.random.randint(2, size=(L)))  # create random message (as a list)\n",
    "        codedMsg   = encode(msg)                                        # encode for channel transmission\n",
    "        recMsg     = bsc(codedMsg, ps[k])                               # send coded message through channel\n",
    "        decodedMsg = viterbi(recMsg)                                    # decode back into binary\n",
    "        BER[k,1]  += numErrors(msg, decodedMsg)                         # count errors\n",
    "    BER[k,1] /= (N*L)                                                   # normalize errors to get Bit Error Rate\n",
    "    \n",
    "plt.figure()\n",
    "plt.semilogy(BER[:,0], BER[:,1], 'bo')\n",
    "plt.grid('on')\n",
    "plt.xlabel('Probability of channel error (au)')\n",
    "plt.ylabel('Bit Error Rate')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[  1.00000000e-02,   5.85937500e-05],\n",
       "       [  2.00000000e-02,   4.88281250e-04],\n",
       "       [  3.00000000e-02,   2.03125000e-03],\n",
       "       [  4.00000000e-02,   3.49609375e-03],\n",
       "       [  5.00000000e-02,   7.53906250e-03],\n",
       "       [  6.00000000e-02,   1.33007812e-02],\n",
       "       [  7.00000000e-02,   2.14257813e-02],\n",
       "       [  8.00000000e-02,   3.42968750e-02],\n",
       "       [  9.00000000e-02,   4.96679687e-02],\n",
       "       [  1.00000000e-01,   6.35742187e-02]])"
      ]
     },
     "execution_count": 57,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "BER"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### (B)\n",
    "Assume we are communicating over a binary symmetric channel with $p =0.05$. Using our repetition encoder, what is the smallest number of repetitions $r$ we would need in order to achieve a superior BER to our convolutional code? Suppose the coded symbols are sent over a 10MHz wireless channel at the rate of $10\\times10^6$ symbols/sec. Compare the data rate, in bits per second (bps), of the convolutional code and the repetition code for this value of $r$. Now suppose, $p=0.02$. What is the minimum $r$ we need to outperform convolutional encoding? How does the data rate compare now?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## <font color='blue'>at $p=.05$ , the convolutional codec has a bit error rate of ~.0075.  The repetition code beats this BER when r = 3, where the BER is ~.00725.  The convolutional code takes two symbols to represent a bit $\\frac{2 symbol}{bit}$ Given $10x10^6$ symbols per second, $bitRate_{convCode} = 5x10^6 bits/s$.  The repetition code with $r=3$ uses 3 symbols per bit, so $bitRate_{r=3} = 3.33x10^6 bits/s$, or 2/3 the speed of the convolutional code.  When $p=.02$, $BER_{conv} = .00048$, which would require $r=5$ repetitions.  $bitRate_{r=5} = 2x10^6 bits/s$ or 2/5 of the speed of the convolutional code."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<i>This lab is adapted from EE126 at UC Berkeley. Special thanks to Kangwook Lee, Rishi Sharma, Sahaana Suri, Ramtin Pedarsani, Kannan Ramchandran for developing the labs</i>"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
